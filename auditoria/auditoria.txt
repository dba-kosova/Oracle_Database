  /**********************************************
  * OBJETIVO  : Oracle-DataBase-audit           *
  * CRIACAO   : 31-12-2019	                    *
  * VERSAO    : 1.0		                        *
  * AUTOR     : Pedro Akira Danno Lima          *
  ***********************************************/


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Oracle Database: AuditorÃ­a (part 1)


auditoria: 
processo de auditoria, vai veririficar se todos os processos de todas as aÃ§Ãµes, estou sendo trabalhadas corretamentes
processo o que acertou, errou, verificou.
Efidencia, podem ser armazenadas em um repositorio, banco de dados.

Auditoria de Oracle 
-Auditoria de sessao
-Auditoria de Objeto



sqlplus / as sysdba



veririfcar 


desc dba_audit_session;





ATIVAR A AUDITORIA DE SESSÃƒO


AUDIT SESSION;


sqlplus HR/oracle;




SELECT USERNAME FROM DBA_AUDIT_SESSION;

SELECT COUNT(*) FROM DBA_AUDIT_SESSION;



SELECT USERNAME,
	   TO_CHAR(TIMESTAMP,'DD-MON-YY HH24:MI:SS'), 
	   ACTION_NAME 
FROM DBA_AUDIT_SESSION;







SELECT USERNAME,
	   TO_CHAR(TIMESTAMP,'DD-MON-YY HH24:MI:SS'), 
	   ACTION_NAME,
	   DECODE(RETURNCODE, '0', 'CONECTADO', 
	   			          '1005', 'nome de usuÃ¡rio sem senha'
	   			          '1017','senha errada')
FROM DBA_AUDIT_SESSION;







#sqlplus HR/oracle;
SQL> exit

sqlplus IX/oracle;






DESATIVAR 

NOAUDIT SESSION;







AUDIDAR SOMENTE AS AÃ‡Ã•ES SATISTATORIAS, AS ERRADAS NÃƒO VAI AUDITAR

AUDIT SESSION WHENEVER SUCCESSFULL;




//AUDITAR SOMENTE AS SESSÃ‡Ã•ES NÃƒO SATISTATORIAS, AS ERRADAS 
AUDIT SESSION WHENEVER NOT SUCCESSFULL;






-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



-Auditoria de Objeto



ATIVAR AUDITORIA TABLE 

audit table;



DESC DBA_AUDIT_OBJECT;



sqlplus / as sysdba


AUDIT TABLE BY SCOTT;

AUDIT TABLE BY HR;



NOAUDIT TABLE;



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Gerenciamento AutomÃ¡tico de Auditoria
Por Fernando Simon
Postado em Abril 2016

Revisado por Marcelo Pivovar - Solution Architect

Auditoria de bancos de dados Oracle pode ser realizada nativamente atravÃ©s de duas formas, auditoria simples (com AUDIT) ou auditoria fina (com Fine Grant Audit â€“ FGA). De qualquer forma elas armazenam os registros em duas tabelas, aud$ e fga_log$.

Quando vocÃª habilita qualquer uma destas duas Ã© importante gerenciar corretamente os registros de auditora, como por exemplo local de armazenamento, tempo de armazenamento e afins. Ã‰ isso que vamos ver abaixo, como fazer isso automaticamente atravÃ©s do Oracle.

Tablespace
O primeiro passo Ã© a tablespaces onde as duas tabelas (aud$ e fga_log$) armazenam os dados. Por padrÃ£o elas sÃ£o armazenadas na tablespace system, mas vocÃª pode mudar isso. Quando a tablespace chega ao limite os registros param de serem inseridos e se a auditoria estiver na system, o banco todo congela (inclusive logins). Para evitar isso o mÃ©todo correto para mover a auditoria para outra tablespace Ã© atravÃ©s do comando abaixo:

BEGIN
  
   --
   --Modificando para a  auditoria simples, a AUD$
   DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_LOCATION(
    audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_AUD_STD
    , audit_trail_location_value => 'TSAUDIT'
     );
  
   --
   --Modificando para a  auditoria de FGA, a FGA_LOG$
   DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_LOCATION(
    audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_FGA_STD
    , audit_trail_location_value => 'TSAUDIT'
     );    

END;

O parÃ¢metro audit_trail_location_value define a tablespace destino e claro que antes de executar o comando acima vocÃª deve cria-la. Se vocÃª armazena muitos registros de auditoria recomenda-se criar a tablespace como bigfile, assim nÃ£o terÃ¡ o limite de 32GB. Se vocÃª jÃ¡ tiver dados nas tabelas de auditoria deverÃ¡ criar a tablespace com tamanho inicial maior do que o tamanho atual das tabelas de auditoria.

No exemplo acima foram movidas as duas tabelas separadamente, mas vocÃª pode as duas ao mesmo tempo. Para isso basta mudar o parÃ¢metro audit_trail_type conforme a tabela abaixo:

AUDIT_TRAIL_AUD_STD: Faz referÃªncia somente a aud$
AUDIT_TRAIL_FGA_STD: Faz referÃªncia somente a fga_log$
AUDIT_TRAIL_DB_STD: Ambas as tabelas, aud$ e fga_log$
Habilitando o Gerenciamento AutomÃ¡tico
O gerenciamento automÃ¡tico da auditoria deve ser habilitado para permitir a movimentaÃ§Ã£o de registros de auditoria entre tablespaces. Se vocÃª nÃ£o moveu as tabelas aud$ e fga_log$ de tablespaces o Oracle automaticamente move os registros da SYSTEM para a SYSAUX. Caso jÃ¡ tenha movido ele nÃ£o moverÃ¡ nada. Observe o comando abaixo.

BEGIN
   DBMS_OUTPUT.ENABLE(10000);
   
--
--Verifica se o init foi habilitado para  as tabelas definidas

   IF NOT DBMS_AUDIT_MGMT.IS_CLEANUP_INITIALIZED(DBMS_AUDIT_MGMT.AUDIT_TRAIL_DB_STD)  THEN
    DBMS_OUTPUT.PUT_LINE('Limpeza de auditoria serÃ¡ inicializada');
   
--
--Inicializando a auditoria para a AUD$  e FGA

   DBMS_AUDIT_MGMT.INIT_CLEANUP(
    audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_DB_STD
     , default_cleanup_interval => 720
   );       

   ELSE

    DBMS_OUTPUT.PUT_LINE('Limpeza de  auditoria jÃ¡ inicializada');
    
   END IF;

END;

AtravÃ©s dele usamos a procedure DBMS_AUDIT_MGMT.IS_CLEANUP_INITIALIZED para verificar se o gerenciamento jÃ¡ foi habilitado. Caso nÃ£o tenha sido, usamos a procedure DBMS_AUDIT_MGMT.INIT_CLEANUP para habilitar, e com um intervalo escolhido de 720 horas entre estas movimentaÃ§Ãµes. Para Oracle 12C vocÃª pode especificar se deseja fazer isso para um PDB especÃ­fico ou para todos.

Recomendo mover as tabelas de auditoria para uma tablespace especÃ­fica, pois deixando no padrÃ£o nÃ£o tem como especificar (atravÃ©s do INIT_CLEANUP) a data e hora que irÃ¡ executar a movimentaÃ§Ã£o e caso vocÃª tenha muitos dados pode impactar no ambiente. Mas caso vocÃª tenha poucos registros de auditoria o INIT_CLEANUP pode ser vÃ¡lido.

CREATE_PURGE_JOB
A forma mais fÃ¡cil de habilitar o gerenciamento automÃ¡tico Ã© criar o job de limpeza de auditoria atravÃ©s da procedure DBMS_AUDIT_MGMT.CREATE_PURGE_JOB. Observe:

BEGIN
   DBMS_AUDIT_MGMT.CREATE_PURGE_JOB(
    audit_trail_type =>  DBMS_AUDIT_MGMT.AUDIT_TRAIL_DB_STD
     , audit_trail_purge_interval => 720 --intervalo de limpeza, em  horas
     , audit_trail_purge_name  => 'JOB_Limpeza_Auditoria' --nome do job
     , use_last_arch_timestamp => TRUE 
   );                        
END;

Os parÃ¢metros sÃ£o:

audit_trail_type define qual o tipo de auditoria que vocÃª deseja limpar, segue a mesma tabela do inÃ­cio do texto.
audit_trail_purge_interval define o intervalo (em horas) que o job serÃ¡ chamado. UtilizarÃ¡ como base a data e hora que o job foi criado, no final serÃ¡ demonstrado como ajustar isso.
audit_trail_purge_name: define o nome do Job.
use_last_arch_timestamp: define quais s registro serÃ£o excluÃ­dos, TRUE indica que serÃ¡ com base em um valor definido (veremos como fazer isso abaixo) e FALSE o job removerÃ¡ todos os registros.
Para o 12c podemos especificar, atravÃ©s do parÃ¢metro container quais serÃ£o os afetados pelo job, todos ou somente o especificado. Quando vocÃª define todos, o job Ã© criado no PDB root e este realiza a limpeza em todos os PDBâ€™s.

Seguindo o exemplo acima, o job JOB_Limpeza_Auditoria irÃ¡ ser executado a cada 720 horas (30 dias) e excluirÃ¡ todos os registros de auditoria definidos pelo last_archive_time (explicarei no prÃ³ximo tÃ³pico). O interessante do job automÃ¡tico Ã© que o prÃ³prio kernel do Oracle se preocupa em localizar os registros a serem removidos e faz isso de forma controlada. Ele nÃ£o remove todos atravÃ©s de um Ãºnico delete, faz isso de forma escalonada a cada 10000 registros.

A data e hora que o job serÃ¡ executado depende do momento de execuÃ§Ã£o do CREATE_PURGE_JOB. Como serÃ£o criados outros jobs auxiliares, mostrarei no final do artigo como aninhar todos e definir corretamente a execuÃ§Ã£o destes.

VocÃª pode verificar atravÃ©s da tabela DBA_AUDIT_MGMT_CLEANUP_JOBS  como ficou a configuraÃ§Ã£o:

SQL>  COL JOB_NAME FORMAT A25
SQL>  COL JOB_FREQUENCY FORMAT A30
SQL>  COL AUDIT_TRAIL FORMAT A40
SQL>  SET LINESIZE 200 
SQL>  SELECT * FROM DBA_AUDIT_MGMT_CLEANUP_JOBS;

JOB_NAME                 JOB_STAT AUDIT_TRAIL                        JOB_FREQUENCY
------------------------ -------- ---------------------------------- ---------------------------
JOB_LIMPEZA_AUDITORIA    ENABLED  STANDARD AND FGA AUDIT TRAIL       FREQ=HOURLY;INTERVAL=720

SQL>
 

Marcando registros a serem excluÃ­dos
No procedimento acima utilizamos o parÃ¢metro use_last_arch_timestamp como TRUE e isso define que a limpeza somente irÃ¡ excluir os registros que definirmos e nÃ£o toda a tabela. Para fazer isso usamos a procedure DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP.

Antes disso uma consideraÃ§Ã£o, geralmente quando precisamos identificar algo na auditoria temos requisitos como: â€œO que JoÃ£o fez a 15 dias atrÃ¡s?â€, â€œQuem fez update na tabela salÃ¡rio este mÃªs?â€. Estes sÃ£o exemplos, mas na grande maioria das vezes precisamos buscar o histÃ³rico e por isso Ã© importante deixar alguns dias no banco para evitar restaurar backup para consulta auditoria.

Por isso que no procedimento que criou o job foi utilizado use_last_arch_timestamp como TRUE. Mas isso deixou o requisito de definir esse ponto atÃ© o momento no qual os dados nÃ£o podem ser apagados. Pense nas tabelas de auditoria com o uma fila, precisamos marcar nessa fila atÃ© onde o job de limpeza pode deletar.

Para isso vamos utilizar a procedure DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP e tambÃ©m criar um job para fazer isso de forma automÃ¡tica (para que o job possa executar, criaremos uma procedure especÃ­fica). A procedure criada:

CREATE  OR REPLACE PROCEDURE AUDIT_DefineMarcacaoAudit

  IS

  BEGIN

  DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP(
   audit_trail_type =>  DBMS_AUDIT_MGMT.AUDIT_TRAIL_AUD_STD
   , last_archive_time => SYSDATE - 45
    );                                                

  DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP(
   audit_trail_type =>  DBMS_AUDIT_MGMT.AUDIT_TRAIL_FGA_STD
   , last_archive_time => SYSDATE - 45
    );                                                

END;
 

A procedure acima utiliza DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP e marca que todos os registros de auditoria mais velhos que 45 dias (na data de execuÃ§Ã£o da procedure) sÃ£o marcados para exclusÃ£o. TambÃ©m estÃ¡ separada a definiÃ§Ã£o de datas para aud$ e fga_log$, assim fica mais fÃ¡cil adaptar para requisitos diferentes de datas. Para deixar a marcaÃ§Ã£o automatizada cria-se o job abaixo:

BEGIN
   
DBMS_SCHEDULER.CREATE_JOB(
    job_name           =>  'JOB_MarcaExclusaoAudit' --nome do job
    , job_type           =>  'STORED_PROCEDURE'
    , job_action         =>   'AUDIT_DefineMarcacaoAudit'
    , repeat_interval     =>  'FREQ=MONTHLY;INTERVAL=1'  -- uma vez ao mes
    , comments           =>  'Job que executa a procedure que marca ate  que ponto a auditoria pode ser removida'
   );

   --
   --Todo o job vem desabilitado por padrao no  scheduler do 11.2, habilitando

   DBMS_SCHEDULER.ENABLE(
    name => 'JOB_MarcaExclusaoAudit'
    );

END; 
 

O job acima executarÃ¡ 1 vez por mÃªs e chamarÃ¡ a procedure que criamos antes. Assim, garantimos que 45 dias ficarÃ£o nas tabelas de auditoria. Se vocÃª observar, no momento que o job de limpeza for executar (ele executa a cada 30 dias tambÃ©m) vocÃª terÃ¡ aproximadamente 75 dias dados armazenados, por isso Ã© importante definir a tablespace de auditoria com um tamanho (ou tipo) condizente com o volume.

Aninhando JOBS
Os jobs criados acima estÃ£o marcados para executar com base no momento de criaÃ§Ã£o e isso nÃ£o Ã© interessante. AlÃ©m disso, nÃ£o adianta executar o job de marcaÃ§Ã£o de exclusÃ£o depois do job de limpeza. Para resolver isso podemos modificar os parÃ¢metros dos jobs atravÃ©s do scheduler. Exemplo:

BEGIN

   --ajusta data inicial comum e aninhada
    DBMS_SCHEDULER.SET_ATTRIBUTE(
     name => 'JOB_MARCAEXCLUSAOAUDIT'
     , attribute => 'start_date'
     , value => TO_TIMESTAMP('15-JAN-13  12.00.00', 'DD-MON-RRRR HH24.MI.SS')
   );

   DBMS_SCHEDULER.SET_ATTRIBUTE(
    name => 'JOB_LIMPEZA_AUDITORIA'
     , attribute => 'start_date'
     , value => TO_TIMESTAMP('15-JAN-13  12.05.00', 'DD-MON-RRRR HH24.MI.SS')
   );
   
   --Segundo sabado do mes
   DBMS_SCHEDULER.SET_ATTRIBUTE(
    name => 'JOB_MARCAEXCLUSAOAUDIT'
     , attribute => 'repeat_interval'
     , value => 'FREQ=MONTHLY;  BYDAY=2SAT'
   );

   --Segundo sabado do mes
   DBMS_SCHEDULER.SET_ATTRIBUTE(
    name => 'JOB_LIMPEZA_AUDITORIA'
     , attribute => 'repeat_interval'
     , value => 'FREQ=MONTHLY;  BYDAY=2SAT'
   );   

END;
 

Com a definiÃ§Ã£o acima temos:

JOB_MARCAEXCLUSAOAUDIT: O que importa aqui Ã© a hora de execuÃ§Ã£o, tem que ser antes do job de exclusÃ£o. A data inicial foi definida como 15 de Janeiro de 2013 (pode ser qualquer data) com horÃ¡rio para as 12:00. TambÃ©m foi definido que ele serÃ¡ executado no segundo sÃ¡bado de cada mÃªs.
JOB_LIMPEZA_AUDITORIA: TambÃ©m tem a data inicial como 15 de Janeiro de 2013, mas o horÃ¡rio Ã© as 12:05. Isso garante que a limpeza sempre executarÃ¡ depois da marcaÃ§Ã£o dos registros. E ele tambÃ©m executa no segundo sÃ¡bado de cada mÃªs.
VocÃª pode modificar os valores acima com base nos seus requisitos, mas o importante Ã© garantir que a marcaÃ§Ã£o dos registros sempre ocorra antes da limpeza.

Tabelas importantes
Algumas tabelas de gerenciamento sÃ£o importantes de serem acompanhadas. A primeira delas Ã© a DBA_AUDIT_MGMT_CLEAN_EVENTS que registra todos os eventos automÃ¡ticos de limpeza que ocorreram e quantos registros foram apagados para cada tabela (por isso aparecem separados):

SQL> COL CLEANUP_TIME FORMAT  A35
SQL> COL AUDIT_TRAIL  FORMAT A25
SQL> SET PAGESIZE 1000
SQL> SET LINESIZE 200
SQL> SELECT audit_trail,  cleanup_time, delete_count FROM DBA_AUDIT_MGMT_CLEAN_EVENTS ORDER BY  cleanup_time DESC;

AUDIT_TRAIL               CLEANUP_TIME                        DELETE_COUNT
------------------------- ----------------------------------- ------------
STANDARD AUDIT TRAIL      09-APR-16 10.33.53.867186 AM +00:00        56470
STANDARD AUDIT TRAIL      09-APR-16 10.33.53.865009 AM +00:00     25217082
STANDARD AUDIT TRAIL      20-MAR-16 10.00.40.545453 AM +00:00       742355
STANDARD AUDIT TRAIL      20-MAR-16 10.00.40.542995 AM +00:00     88551571
..
..
STANDARD AUDIT TRAIL      25-JUL-13 02.10.14.479176 PM +00:00       340175
STANDARD AUDIT TRAIL      25-JUL-13 02.10.14.465855 PM +00:00      9362182

68 rows selected.

SQL>
 

Outra tabela importante Ã© DBA_AUDIT_MGMT_LAST_ARCH_TS que pode ser consulta para saber atÃ© onde foi a marcaÃ§Ã£o de registros a serem limpos. No exemplo abaixo a marcaÃ§Ã£o informa que o job de limpeza somente apagarÃ¡ registros atÃ© 26/02/2016 12:00:

SQL>  COL LAST_ARCHIVE_TS FORMAT A35
SQL>  SELECT * FROM DBA_AUDIT_MGMT_LAST_ARCH_TS;

AUDIT_TRAIL               RAC_INSTANCE LAST_ARCHIVE_TS
------------------------- ------------ ------------------------------------
STANDARD  AUDIT TRAIL                0 24-FEB-16  12.00.00.000000 AM +00:00
FGA  AUDIT TRAIL                     0 24-FEB-16 12.00.00.000000 AM  +00:00

SQL>
 

Outra tabela Ã© a DBA_AUDIT_MGMT_CONFIG_PARAMS que mostra como os estÃ£o os parÃ¢metros de gerenciamento da auditoria:

SQL>  COL PARAMETER_VALUE FORMAT A25
SQL>  COL PARAMETER_NAME FORMAT A25
SQL>  SELECT * FROM DBA_AUDIT_MGMT_CONFIG_PARAMS;

PARAMETER_NAME             PARAMETER_VALUE           AUDIT_TRAIL
-------------------------  ------------------------- -----------------------
DB  AUDIT TABLESPACE       TSAUDITTJ                 STANDARD AUDIT TRAIL
DB  AUDIT TABLESPACE       TSAUDITTJ                 FGA AUDIT TRAIL
AUDIT  FILE MAX SIZE       10000                     OS AUDIT TRAIL
AUDIT  FILE MAX SIZE       10000                     XML AUDIT TRAIL
AUDIT  FILE MAX AGE        5                         OS AUDIT TRAIL
AUDIT  FILE MAX AGE        5                         XML AUDIT TRAIL
DB  AUDIT CLEAN BATCH SIZE 10000                     STANDARD AUDIT TRAIL
DB  AUDIT CLEAN BATCH SIZE 10000                     FGA AUDIT TRAIL
OS  FILE CLEAN BATCH SIZE  1000                      OS AUDIT TRAIL
OS  FILE CLEAN BATCH SIZE  1000                      XML AUDIT TRAIL
DEFAULT  CLEAN UP INTERVAL 720                       STANDARD AUDIT TRAIL
DEFAULT  CLEAN UP INTERVAL 720                       FGA AUDIT TRAIL

12 rows selected.

SQL>
 

Como foram criados jobs manualmente Ã© importante verificar a execuÃ§Ã£o deles. Para isso utilizamos a tabela do prÃ³prio schedule. Observe os parÃ¢metros (blocos e procedures) bem como as datas de execuÃ§Ã£o aninhadas:

SQL>  COL OWNER FORMAT A5
SQL>  COL JOB_NAME FORMAT A25
SQL>  COL JOB_TYPE FORMAT A20
SQL>  COL REPEAT_INTERVAL FORMAT A25
SQL>  COL JOB_ACTION FORMAT A30
SQL>  COL START_DATE FORMAT A35
SQL>  COL NEXT_RUN_DATE FORMAT A35
SQL>  SET LINESIZE 300
SQL>  SELECT DSJ.OWNER, DSJ.JOB_NAME, DSJ.JOB_TYPE, DSJ.JOB_ACTION, DSJ.START_DATE, DSJ.REPEAT_INTERVAL, 
DSJ.NEXT_RUN_DATE, DSJ.RUN_COUNT, DSJ.FAILURE_COUNT
   2  FROM  DBA_SCHEDULER_JOBS DSJ
   3   WHERE JOB_NAME IN ('JOB_LIMPEZA_AUDITORIA', 'JOB_MARCAEXCLUSAOAUDIT');

OWNER JOB_NAME                  JOB_TYPE             JOB_ACTION                                                   
----- ------------------------- -------------------- -------------------------------------------------------------
SYS   JOB_LIMPEZA_AUDITORIA     PLSQL_BLOCK          BEGIN DBMS_AUDIT_MGMT.CLEAN_AUDIT_TRAIL(3,  TRUE);  END;     
SYS   JOB_MARCAEXCLUSAOAUDIT    STORED_PROCEDURE     AUDIT_DefineMarcacaoAudit                                    

START_DATE                           REPEAT_INTERVAL           NEXT_RUN_DATE                        RUN_COUNT 
-----------------------------------  ------------------------- -----------------------------------  --------- 
15-JAN-13 12.05.00.000000 AM -03:00  FREQ=MONTHLY; BYDAY=2SAT  14-MAY-16 12.05.00.700000 AM -03:00        34
15-JAN-13 12.00.00.000000 AM -03:00  FREQ=MONTHLY; BYDAY=2SAT  14-MAY-16 12.00.00.200000 AM -03:00        32

FAILURE_COUNT
-------------
            1
            0

SQL>
 

Outros cuidados
Se vocÃª desejar pode criar um job para mover as tabelas de auditoria de tempos em tempos (como por exemplo no 3Âº sÃ¡bado do mÃªs). Como as tabelas recebem deletes pelo job de limpeza o â€œinÃ­cioâ€ dela fica desfragmentado e novos registros poderÃ£o ser adicionados no fim. Em resumo ela eventualmente pode nunca reduzir de tamanho.

Se vocÃª mover elas (atravÃ©s da DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_LOCATION) vocÃª garante que na nova tablespace somente o tamanho necessÃ¡rio Ã© utilizado. VocÃª tambÃ©m pode fazer um shrink se desejar. Se quiser fazer isso, crie uma procedure para mover e um job para automatizar o processo.

Todos os procedimentos acima foram executados com o usuÃ¡rio sys. Com mÃ­nimas adaptaÃ§Ãµes vocÃª pode executar os procedimentos acima nos bancos Oracle 10.2 atÃ© o 12C.

Gerenciamento
Com tudo isso vocÃª tem um controle automatizado dos seus registros de auditoria. Garantindo que vocÃª consiga consultar dados histÃ³ricos de auditoria sem precisar voltar backup. AlÃ©m disso garante que as tablespaces system e sysaux nÃ£o ficarÃ£o cheias de registros.

ReferÃªncias
DBMS_AUDIT_MGMT para 11.2 (https://docs.oracle.com/cd/E18283_01/appdev.112/e16760/d_audit_mgmt.htm)
DBMS_AUDIT_MGMT para 12C (https://docs.oracle.com/database/121/ARPLS/d_audit_mgmt.htm)

 

Fernando Simon DBA do Tribunal de JustiÃ§a de Santa Catarina. Trabalha como DBA a diversos anos, desde o Oracle 9i atÃ© o Oracle 12c. Tem experiÃªncia prÃ¡tica com Oracle Exadata (do V2 ao X5) e soluÃ§Ãµes que dependem de High Availability como Zero Data Loss, Data Guard, Oracle RAC e replicaÃ§Ãµes diversas. TambÃ©m atua como palestrante em eventos Oracle no Brasil. Blog: http://www.fernandosimon.com/blog.

Este artigo foi revisto pela equipe de produtos Oracle e estÃ¡ em conformidade com as normas e prÃ¡ticas para o uso de produtos Oracle.


















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Oracle Database 12c Security: "Auditoria no 12c: Unified Auditing" ( Part I )
Por Joel Perez , Aman Sharma , Karan Dodwal (OCM) & Carlos H. Y. Furushima 
Postado em Abril 2015

Revisado por Marcelo Pirovar - Solution Architect

IntroduÃ§Ã£o
Uma funÃ§Ã£o do administradores de banco de dados (DBA) Ã© zelar pela seguranÃ§a do banco de dados, Ã© comum verificar que muitos recursos de seguranÃ§a nÃ£o sÃ£o implementados ou operam em configuraÃ§Ãµes default (padrÃ£o de fÃ¡brica). Devido a heterogeneidade das soluÃ§Ãµes em cenÃ¡rios de infra-estrutura de TI e possÃ­veis riscos/desvios na integraÃ§Ã£o entre essas soluÃ§Ãµes heterogÃªneas, faz com que o DBA fique engessado para implementaÃ§Ã£o de certos mÃ©todos de autenticaÃ§Ã£o nÃ£o-local (kerberos por exemplo). Contudo ainda Ã© de sua responsabilidade, saber quem estÃ¡ entrando/saindo e utilizando seu banco de dados, uma forma eficiente e fÃ¡cil de fazer isso Ã© por meio da auditoria.

Tipos de auditoria (Auditingoptions) antes do 12c
Em versÃµes anteriores ao 12c, o DBA pode implementar cinco tipos de configuraÃ§Ã£o de auditoria, sÃ£o elas:

MandatoryAuditing (Auditoria obrigatÃ³ria) - Essa auditoria estÃ¡ sempre habilitada e monitora o shutdown e startup do banco de dados e operaÃ§Ãµes de logon como SYSDBA, SYSASM ou SYSOPER.
Standard Auditing (PadrÃ£o auditoria) - Essa auditoria Ã© opcionalmente habilitada pelo DBA, para auditar instruÃ§Ã£o SQL, privilÃ©gios, schema objects e atividade de rede (network) ou multicamadas (multitier). Este tipo de auditoria Ã© definida e controlada sob o nÃ­vel de banco de dados.
Value-basedAuditing (Auditoria baseada em valor) - Auditoria baseada em valor (Value-basedAuditing) foi introduzida com intuito de capturar operaÃ§Ãµes que modificam valores, ou seja, operaÃ§Ãµes DML que ocorre na tabela, esse tipo de auditoria utiliza-se de triggers de banco de dados, onde essa Ã© disparada em funÃ§Ã£o de um evento de alteraÃ§Ã£o (operaÃ§Ã£o DML).
Fine-GrainedAuditing (Auditoria refinada): Auditoria refinada (Fine grainedauditing) Ã© uma auditoria que visa capturar aÃ§Ãµes baseadas no conteÃºdo acessado ou modificado, onde sÃ£o criadas diretivas (policies) para disparar eventos de auditoria (trigger auditevents) quando alguÃ©m tenta executar aÃ§Ãµes sobre a condiÃ§Ã£o especificada na definiÃ§Ã£o da polÃ­tica.
SysAuditing (auditoria do sys) - Este tipo de auditoria permite que o DBA, seja monitorado, ao se logar com SYS, suas aÃ§Ãµes serÃ£o gravadas em um arquivo do sistema operacional mesmo que audit_trail Ã© definido como none. O parÃ¢metro de instance AUDIT_SYS_OPERATIONS controla a habilitaÃ§Ã£o ou desativaÃ§Ã£o da auditoria do sys.
AlÃ©m destas soluÃ§Ãµes, para proteger as informaÃ§Ãµes de seus sistemas, ha tambÃ©m o Oracle AuditVault uma plataforma corporativa de auditoria e monitoramento de seguranÃ§a. Combinada todas essas opÃ§Ãµes, cria-se um robusto sistema de monitoramento, possibilitando o DBA ter um arsenal completo no combate a usuÃ¡rio mal-intencionado, atividades suspeitas e/ou desvios de conduta.

O tem de errado com as opÃ§Ãµes de auditoria disponÃ­vel no 11g?
Na verdade, nÃ£o hÃ¡ nada de errado com as opÃ§Ãµes disponÃ­veis, contudo, a gestÃ£o da auditoria para o DBA neste cenÃ¡rio Ã© extremamente trabalhosa. Por exemplo, para habilitar o Standard Auditing (PadrÃ£o auditoria), os parÃ¢metros AUDIT_TRAIL e AUDIT_FILE_DEST, devem ser setados. Se vocÃª estiver planejando usar o Fine-GrainedAuditing (Auditoria refinada) ou somente o Standard Auditing, os registros de auditoria (auditrecords), sÃ£o armazenados em SYS.FGA_LOG$ ou SYS.AUD$, isso demanda uma atenÃ§Ã£o especial no armazenamento, uma vez que essas tabelas, tentem a crescer em funÃ§Ã£o do uso do banco de dados e com o passar do tempo, os registros de auditoria (auditrecords) ficarÃ£o obsoletos, obrigando o DBA, criar tarefas de expurgo. Caso estiver usando algo mais robusto como Oracle AuditVault, Ã© papel do DBA, gerenciar as tabelas com os dados do Vault, como DVSYS.AUDIT_TRAIL$, para usuÃ¡rios como o SYS, registros de auditoria (auditrecords) sÃ£o criados usando o usuÃ¡rio ROOT, o que pode dificultar a gestÃ£o, no que se refere a processos de TI da companhia, uma vez que nem sempre o DBA tem o acesso de super usuÃ¡rio (ROOT). Resumindo, isso significa, que hÃ¡ muita coisa envolvida (necessidade de hardware, mÃ£o de obra, planejamento no processo de TI, etc.), do que apenas habilitar a auditoria para o banco de dados.

IntroduÃ§Ã£o a UnifiedAuditing
Foi introduzida no Oracle 12c um novo mecanismo de auditoria, onde este novo regime, permite agrupar vÃ¡rias diretivas de auditoria em uma Ãºnica politica, por este motivo, Ã© empregado o termo "Unified" (unificaÃ§Ã£o) como prefixo de "UnifiedAuditing". Ã‰ possÃ­vel criar polÃ­ticas baseado em aÃ§Ãµes e condiÃ§Ãµes. A implementaÃ§Ã£o deste novo tipo de polÃ­tica Ã© controlada por um novo usuÃ¡rio (schema AUDSYS), onde suas tabelas para trilha de auditoria (auditingtrailtables - metadados de auditoria) sÃ£o somente leitura (read-only), atÃ© mesmo para o usuÃ¡rio SYS, com isso todos os tipos de trilhas de auditoria seriam gerenciados por um Ãºnico usuÃ¡rio e em uma tabela de trilha de auditoria, ou seja, torna esta informaÃ§Ã£o disponÃ­vel em um formato uniforme, a concessÃ£o de acesso para os dados de trilha de auditoria, permite duas perspectiva, viewer (ver os dados) ou admin (administrar os dados).

Arquitetura de diretiva da UnifiedAuditing

O usuÃ¡rio owner do "unifiedauditing" (Auditoria unificada) Ã© o AUDSYS. Na SGA, existem background queues (queuesin-memory - duas por client), que armazenam as entradas de auditoria (Auditrecords) de forma volÃ¡til, para que posteriormente sejam armazenadas de forma permanente em disco, o flush (despacho das entradas de auditoria) Ã© feito pelo novo processo background GEN0 (processo de execuÃ§Ã£o de tarefas gerais - General TaskExecution process) ou de forma manual utilizando a DBMS_AUDIT_MGMT, o armazenamento Ã© feito em uma tabela somente leitura localizado no schema AUDSYS no tablespace SYSAUX.

A trilha de auditoria unificada (unifiedaudittrail), reside em uma tabela somente leitura (Read-Only) no esquema AUDSYS no tablespace SYSAUX, torna esta informaÃ§Ã£o disponÃ­vel em um formato uniforme na view de dicionÃ¡rio de dados UNIFIED_AUDIT_TRAIL, ou seja, todas as trilhas de auditoria existentes no 11g, foram unificadas em uma Ãºnica trilha agora no 12c (view UNIFIED_AUDIT_TRAIL).

OBS.: Para executar o flush manual das entradas de auditoria (Auditrecords) localizado no background queues para o schema AUDSYS.

Exec SYS.DBMS_AUDIT_MGMT.Flush_Unified_Audit_Trail;

Ha duas background queues (filas) por server process (em conexÃµes do tipo dedicada), assim quando um background queue (uma fila) estÃ¡ cheia, seu conteÃºdo Ã© despachado para disco pelo background GEN0 e o server process (por exemplo RMAN), pode usar a outra background queue (uma fila) para armazenar de forma volÃ¡til suas informaÃ§Ãµes de auditoria. A quantidade de memÃ³ria alocada dentro da SGA que serÃ¡ dedicada para todas as background queues (filas) Ã© 1MB, esse valor pode ser alterado pelo DBA via parÃ¢metro de instance UNIFIED_AUDIT_SGA_QUEUE_SIZE (valor default = 1MB e valor mÃ¡ximo = 30MB). A decisÃ£o de alterar o valor de memÃ³ria alocada deve ser feita com base no montante esperado (workload - quantidade) de informaÃ§Ãµes de auditoria a ser gerados. Para a maioria dos sistemas, o padrÃ£o de 1MB deve ser suficiente.

Ha dois diferentes modo de operaÃ§Ã£o, referente a escrita das entradas de auditoria para Ã¡rea de armazenamento permanente (disco), como citado anteriormente, as entradas de auditoria quando geradas, sÃ£o primeiramente armazenadas em Ã¡rea volÃ¡til (SGA) e posteriormente escrito para Ã¡rea permanente (disco) via processo GEN0, essa escrita pode ser imediata ou sob demanda (quando a background queue chegar no seu limite mÃ¡ximo de capacidade). O modo de escrita (gravaÃ§Ã£o) imediata, faz com que a frequÃªncia de I/O, seja mais intensa e como consequÃªncia, Ã© necessÃ¡rio que o subsistema I/O comporte essa a pressÃ£o que estÃ¡ sendo exercida, caso contrÃ¡rio, o sistema como um todo, iria ser impactando, degradando o desempenho significativamente. Ã‰ possÃ­vel alterar o modo de operaÃ§Ã£o utilizando o pacote DBMS_AUDIT_MGMT.

Modo de operaÃ§Ã£o imediata (Immediate-Write mode)

EXECUTE DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_PROPERTY  ( DBM_MS_AUDIT_MGMT.AUDIT_TRAIL_UNIFIED,
DBMS_AUDIT_MGMT.AUDIT_TRAIL_WRITE_MODE,
DBMS_AUDIT_MGMT.AUDIT_TRAIL_IMMEDIATE_MODE );


Modo de operaÃ§Ã£o sob demanda (Queued-Write mode) # Default

EXECUTE  DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_PROPERTY (  DBM_MS_AUDIT_MGMT.AUDIT_TRAIL_UNIFIED,
DBMS_AUDIT_MGMT.AUDIT_TRAIL_WRITE_MODE, 
DBMS_AUDIT_MGMT.AUDIT_TRAIL_QUEUED_MODE );


O default Ã© sempre o modo de operaÃ§Ã£o sob demanda.
OBS.: Ã‰ importante ressaltar que se houve um crash instance (queda da instance), pode haver um perda das entradas de auditoria, caso o processo background GEN0 nÃ£o completar a escrita para disco.


Implementando UnifiedAuditing
Em banco de dados que passaram por um processo de upgrade release para 12c ou um banco de dados recÃ©m criado, a unifiedauditing (auditoria unificada) nÃ£o estÃ¡ habilitada por default na versÃ£o 12c (12.1.0.2), em caso de uma heranÃ§a de polÃ­ticas de auditoria, oriunda de versÃµes pre-12c (por exemplo, 11gR2 ou inferior, quando unifiedauditing nÃ£o existia) Ã© possÃ­vel manter o mecanismo antigo, migrar para o novo ou usar ambos em um modo misto (MixedAuditmode).
Para banco de dados que passaram por um processo de upgrade release para 12c, quaisquer diretivas ou polÃ­ticas de auditoria (audit policies) previamente configurados em seus respectivos destinos permaneceram habilitadas. AlÃ©m deles, Ã© possÃ­vel criar novas diretiva usando o comando CREATE AUDIT POLICY e habilita-la usando o comando AUDIT. Ã‰ possÃ­veltambÃ©m utilizar diretivas prÃ©-definida (template de auditoria) como ORA_SECURECONFIG, ORA_ACCOUNT_MGMT e ORA_DATABASE_PARAMETER, essas diretivas/polÃ­ticas sÃ£o criadas juntamente com o banco de dados, usando o script secconf.sql, que estÃ¡ localizado em $ORACLE_HOME/rdbms/admin.


Este artigo continua na sua parte II: Oracle Database 12c Security: "Auditoria no 12c: Unified Auditing" (Part II)


Joel PÃ©rez Ã© um DBA Especialista (Oracle ACE Director, OCM Cloud Admin. & OCM11g ). Com mais de 14 anos de experiÃªncia do mundo Oracle Technology, especializado em arquitetura e implementaÃ§Ã£o de soluÃ§Ãµes como: Cloud, Alta disponibilidade, Disaster/Recovery, Upgrades, replicaÃ§Ã£o e todos as Ã¡reas relacionadas com bancos de dados Oracle. Consultor internacional com deveres, conferÃªncias e atividades em mais de 50 paÃ­ses e inÃºmeros clientes em todo o mundo. Palestrante regular nos eventos Oracle em todo o mundo como: OTN LAD, OTN MENA, OTN APAC e muito mais. Joel sempre foi conhecido por ser pioneiro em tecnologia Oracle desde os primeiros dias de sua carreira sendo o primeiro latino-americano premiado como "OTN Expert" no ano de 2003 pela Oracle Corporation, um dos primeiros "ACE Oracle" no Oracle ACE Program no ano de 2004, um dos primeiros OCP Database Cloud Administrator em todo o mundo no ano de 2013 e como um das maiores realizaÃ§Ãµes profissionais em sua carreira, recentemente ele foi homenageado como o primeiro "OCM Database Cloud Administrator" do mundo.

Aman Sharma Ã© um especialista em banco de dados Oracle, um Oracle Certified Professional (9i, 10g, 11g), um Oracle Certified Expert para Linux e SQL e Sun Certified System Admin com mais de 6 anos de experiÃªncia. Aman trabalha como instrutor de formaÃ§Ã£o de profissionais ao redor da Ãsia-PacÃ­fico em tecnologias da Oracle relacionadas. Antes disso, ele trabalhou como DBA para uma empresa de desenvolvimento de software de grande porte. Em seu tempo livre, quando Aman nÃ£o estÃ¡ ensinando ou viajando, ele gosta de passar o tempo em vÃ¡rios fÃ³runs da Oracle atravÃ©s da web.

Karan Dodwal (OCM) Ã© um Oracle arquiteto com especializaÃ§Ã£o em Oracle High Availability. Ele Ã© um DBA Oracle Certified Master (OCM) com vÃ¡rios anos de experiÃªncia em banco de dados Oracle e no desenvolvimento Oracle. Ele trabalha como consultor Oracle e jÃ¡ realizou diversos serviÃ§os e treinamentos sobre os produtos da Oracle na Ãsia PacÃ­fico, Ãsia do Sul e na Grande China. Ele Ã© um speaker do All India Oracle Users Group (North India Chapter) e apresenta sessÃµes no Oracle Technology. Ele tem vÃ¡rias configuraÃ§Ã£o feitas do Oracle High Availability em todas as plataformas para missÃµes crÃ­ticas do Oracle Database. Ele Ã© um expert em todas as soluÃ§Ãµes de High Availability da Oracle como RAC, Exadata, Data Guard e outros. Ele freqÃ¼entemente publica artigos em diversos sites e no seu bloghttp://karandba.blogspot.in e participa ativamente de eventos do grupo de usuÃ¡rios Oracle AIOUG AllIndia Oracle UsersGroup (North IndiaChapter) e ajuda diversos usuÃ¡rio no OTN FÃ³rum da Oracle.

Carlos H. Y. Furushima Ã© um especialista em banco de dados relacional, trabalhando como consultor de TI, atuando principalmente como o Oracle Database Administrator (DBA Oracle). Tem uma vasta experiÃªncia e conhecimento em "Performance, diagnosticand tuning", "High Availability", "Backup & Recovery" e "Exadata". Ele tambÃ©m estÃ¡ entusiasmado com sistema operacional Linux/Unix, onde contribui com o desenvolvimento do cÃ³digo do kernel Linux em parceria com a comunidade "GNU Linux", com criaÃ§Ã£o e revisÃ£o de novas funcionalidades, melhorias e correÃ§Ãµes de bugs. Recentemente, Furushima divide seu tempo com consultoria especializada em banco de dados Oracle e estudos sobre "Oracle Internals", com o objetivo de descobrir e entender os benefÃ­cios do bancos de dados Oracle em plataforma Linux/Unix.

Este artigo foi revisto pela equipe de produtos Oracle e estÃ¡ em conformidade com as normas e prÃ¡ticas para o uso de produtos Oracle.

    E-mail this page E-mail this page    Printer View Printer View








FONTE: https://www.oracle.com/technetwork/pt/articles/idm/auditoria-security-database-12c-2524430-ptb.html
















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


12c Unified Auditing and AUDIT_TRAIL=DB in mixed mode
By Oracle TeamFebruary 23, 2017Database Administration & Monitoring2 Comments
    
By Franck Pachot
.
Oracle enables some auditing by default, and if you donâ€™t do anything, the tables where it is stored will grow in SYSAUX. Donâ€™t wait to get an alert when it is too late. Everything that fills something automatically must be managed to archive or purge automatically. If not, one day you will have a problem.

Imagine that you have 5 features doing something similar but in a different way because they were implemented one at a time. You want to stop this and have only 1 unified feature. Thatâ€™s great. But you are also required to maintain compatibility with previous version, which means that you actually implemented a 5+1=6th feature ðŸ™

Unified Auditing
This exactly what happens with Unified Auditing. Because of this compatibility requirement, it is declined in two modes:

The â€˜mixed modeâ€™ that keeps all compatibility as the 5+1 case in my example
The â€˜pure modeâ€™ that do not take care of the past and is actually the one that unifies all. The real â€˜Unifiedâ€™ one.
You are in â€˜mixed modeâ€™ by default and you see it as if there is nothing new enabled:

SQL> select parameter,value from v$option where parameter='Unified Auditing';
 
PARAMETER VALUE
--------- -----
Unified Auditing FALSE

But there may be something enabled if the old auditing is enabled, because it is actually a mixed mode.

AUDIT_TRAIL=DB
Let me explain. I use the old auditing:

SQL> show parameter audit
NAME TYPE VALUE
---------------------------- ------- --------------------------------
audit_trail string DB

This means that I have the default audits (such as logon, logoff, ALTER/CREATE/DROP/GRANT ANY, and so on.
In addition to that, I enabled the audit of create table:

SQL> audit create table;
Audit succeeded.

I do some of these stuff and I can see info in the old audit trail:
SQL> select action_name,sql_text from dba_audit_trail;
 
ACTION_NAME SQL_TEXT
----------- --------
CREATE TABLE
LOGON
SELECT
LOGON
LOGOFF

If you are in that case, you probably manage this trail. Our recommandation is either to disable audit, or to manage it.

But once upgraded to 12c, did you think about managing the new unified audit trail?

SQL> select audit_type,unified_audit_policies,action_name,return_code,count(*) from unified_audit_trail group by audit_type,unified_audit_policies,action_name,return_code order by 1,2,3;
---- ------ ------------------------------------------------------------------ ---- ------------------- ----- -- --------------------------------------------------------- ----- -- ------
AUDIT_TYPE UNIFIED_AUDIT_POLICIES ACTION_NAME RETURN_CODE COUNT(*)
Standard ORA_LOGON_FAILURES LOGON 0 2
Standard ORA_LOGON_FAILURES LOGON 1017 1
Standard ORA_SECURECONFIG CREATE ROLE 0 1
Standard ORA_SECURECONFIG DROP ROLE 0 1
Standard EXECUTE 0 1

Even with Unified Auditing set to off, some operations are audited when AUDIT_TRAIL=DB. If you donâ€™t want them you have to disable them:

noaudit policy ORA_SECURECONFIG;
noaudit policy ORA_LOGON_FAILURES;

As you see, in mixed mode the new unified auditing is enabled, and AUDIT_TRAIL is not ignored. This is the mode to use until you have migrated all your policies and audit trail queries to the new one. However you can see that in mixed mode, there is no double auditing but only new default policies. The old policies are only logged to the old audit trail.

But if you donâ€™t use auditing, then you donâ€™t want the mixed mode.

uniaud_on
This is done with an instance shutdown, relinking onLinux or renaming a ddl on Windows.


SQL> shutdown immediate;
ORACLE instance shut down.
SQL> host ( cd $ORACLE_HOME/rdbms/lib ; make -f ins_rdbms.mk uniaud_&2 ioracle ORACLE_HOME=$ORACLE_HOME )
/usr/bin/ar d /u01/app/oracle/product/12.2.0/dbhome_1/rdbms/lib/libknlopt.a kzanang.o
/usr/bin/ar cr /u01/app/oracle/product/12.2.0/dbhome_1/rdbms/lib/libknlopt.a /u01/app/oracle/product/12.2.0/dbhome_1/rdbms/lib/kzaiang.o
chmod 755 /u01/app/oracle/product/12.2.0/dbhome_1/bin
 
- Linking Oracle
...

And then you are in â€˜pure modeâ€™:


SQL> select parameter,value from v$option where parameter='Unified Auditing';
 
PARAMETER VALUE
--------- -----
Unified Auditing TRUE

In that mode, AUDIT_TRAIL is ignored and you will never see new rows in the old AUD$:

SQL> select action_name,sql_text from dba_audit_trail;
 
no rows selected

However, as in the mixed mode you will have to manage the new audit trail. My best recommandation is to keep it and add a purge job. One day you may want to have a look at unsuccessful logins of the past few days. But you still have the choice to disable the default polices, and then the only things you will see are the operations done on the trail:

AUDIT_TYPE UNIFIED_AUDIT_POLICIES ACTION_NAME SQL_TEXT
---------- ---------------------- ----------- --------
Standard EXECUTE BEGIN dbms_audit_mgmt.flush_unified_audit_trail; END;^@
Standard EXECUTE BEGIN dbms_audit_mgmt.clean_audit_trail(audit_trail_type => dbms_audit_mgmt.audi
Standard EXECUTE BEGIN dbms_audit_mgmt.flush_unified_audit_trail; END;^@

The reason is that if a hacker getting super administrator rights has tried to whipe his traces, then at least this suspect operation remains.

Test it
To validate this blog post, Iâ€™ve tested all scenarios on 12.2.0.1 with the combination of:

audit_trail=db or audit_trail=none
uniaud_on or uniaud_off
audit or noaudit policy for ORA_SECURECONFIG and ORA_LOGON_FAILURES
For each combination, Iâ€™ve purged both audit trails (AUD$ and AUD$UNIFIED) and run a few statements that are logged by default or by explicit audit.

So what?
Basically, the recommandation is still the same as before: either disable the audit or schedule a purge. There is no purge by default because auditing is different than logging. When your security policy is to audit some operations, they must not be purged before being archived, or processed.

When you upgrade to 12c:

If you want to manage only the old audit, then you should disable ORA_LOGON_FAILURES and ORA_SECURECONFIG.
If you want to manage both, then add a job to purge the unified audit trail (audit_trail_type=>dbms_audit_mgmt.audit_trail_unified).
If you donâ€™t use the old auditing, then enable the â€˜pure modeâ€™. But then, AUDIT_TRAIL=NONE is ignored, so:
If you donâ€™t use the new unified auditing, then disable ORA_LOGON_FAILURES and ORA_SECURECONFIG.
Or use the new unified auditing and set a job to purge it regularly.
And control the growth of SYSAUX:

SQL> select occupant_name,schema_name,occupant_desc,space_usage_kbytes from v$sysaux_occupants where occupant_name like 'AUD%';
 
OCCUPANT_NAME SCHEMA_NAME OCCUPANT_DESC SPACE_USAGE_KBYTES
------------- ----------- ------------- ------------------
AUDSYS AUDSYS AUDSYS schema objects 1280
AUDIT_TABLES SYS DB audit tables 0

SYS â€˜DB audit tablesâ€™ is the old one, filled in â€˜mixed modeâ€™ only. AUDSYS â€˜AUDSYS schema objectsâ€™ is the new unified one, filled in both modes.

But I have something to add. The default policies do not audit something that you are supposed to do so frequently, it should not fills hundreds of MB before several decades.
If you get this during the last hour:
SQL> select audit_type,unified_audit_policies,action_name,return_code,count(*)
2 from unified_audit_trail where event_timestamp>sysdate-1
3 group by audit_type,unified_audit_policies,action_name,return_code
4 order by count(*);
AUDIT_TYPE UNIFIED_AUDIT_POLICIES ACTION_NAME RETURN_CODE COUNT(*)
---------- ---------------------- ----------- ----------- --------
Standard AUDIT 0 2
Standard EXECUTE 0 4
Standard ORA_SECURECONFIG CREATE ROLE 0 9268
Standard ORA_LOGON_FAILURES LOGON 1017 348 

then the problem is not auditing but an attack, either from a hacker of because of your application design connecting for each execution or running DDL all the time.




FONTE: https://blog.dbi-services.com/12c-unified-auditing-and-audit_traildb-in-mixed-mode/















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------








  /******************************************************************************************************************************
  *                                                   		REFERENCIAS      	                                  				          *
  *https://www.youtube.com/watch?v=pfRqZUyLPQY&t=56s							                		   		   				                          *
  *https://www.youtube.com/watch?v=5OF3JJUx6dE																	   				                                      *
  *https://www.youtube.com/watch?v=rSLv1mge_uw 																	   				                                      *
  *https://www.oracle.com/technetwork/pt/articles/database-performance/gerenciamento-automatico-auditoria-3002076-ptb.html		  *
  *https://www.oracle.com/technetwork/pt/articles/idm/auditoria-security-database-12c-2524430-ptb.html                          *
  *https://blog.dbi-services.com/12c-unified-auditing-and-audit_traildb-in-mixed-mode/                                          *
  *https://www.youtube.com/watch?v=pHjvR_4gSwo                                                                                  *
  *******************************************************************************************************************************/