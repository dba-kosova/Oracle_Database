  /**********************************************
  * OBJETIVO  : Oracle-DataBase-audit           *
  * CRIACAO   : 31-12-2019	                    *
  * VERSAO    : 1.0		                        *
  * AUTOR     : Pedro Akira Danno Lima          *
  ***********************************************/


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Oracle Database: Auditoría (part 1)


auditoria: 
processo de auditoria, vai veririficar se todos os processos de todas as ações, estou sendo trabalhadas corretamentes
processo o que acertou, errou, verificou.
Efidencia, podem ser armazenadas em um repositorio, banco de dados.

Auditoria de Oracle 
-Auditoria de sessao
-Auditoria de Objeto



sqlplus / as sysdba



veririfcar 


desc dba_audit_session;





ATIVAR A AUDITORIA DE SESSÃO


AUDIT SESSION;


sqlplus HR/oracle;




SELECT USERNAME FROM DBA_AUDIT_SESSION;

SELECT COUNT(*) FROM DBA_AUDIT_SESSION;



SELECT USERNAME,
	   TO_CHAR(TIMESTAMP,'DD-MON-YY HH24:MI:SS'), 
	   ACTION_NAME 
FROM DBA_AUDIT_SESSION;







SELECT USERNAME,
	   TO_CHAR(TIMESTAMP,'DD-MON-YY HH24:MI:SS'), 
	   ACTION_NAME,
	   DECODE(RETURNCODE, '0', 'CONECTADO', 
	   			          '1005', 'nome de usuário sem senha'
	   			          '1017','senha errada')
FROM DBA_AUDIT_SESSION;







#sqlplus HR/oracle;
SQL> exit

sqlplus IX/oracle;






DESATIVAR 

NOAUDIT SESSION;







AUDIDAR SOMENTE AS AÇÕES SATISTATORIAS, AS ERRADAS NÃO VAI AUDITAR

AUDIT SESSION WHENEVER SUCCESSFULL;




//AUDITAR SOMENTE AS SESSÇÕES NÃO SATISTATORIAS, AS ERRADAS 
AUDIT SESSION WHENEVER NOT SUCCESSFULL;






-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



-Auditoria de Objeto



ATIVAR AUDITORIA TABLE 

audit table;



DESC DBA_AUDIT_OBJECT;



sqlplus / as sysdba


AUDIT TABLE BY SCOTT;

AUDIT TABLE BY HR;



NOAUDIT TABLE;



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Gerenciamento Automático de Auditoria
Por Fernando Simon
Postado em Abril 2016

Revisado por Marcelo Pivovar - Solution Architect

Auditoria de bancos de dados Oracle pode ser realizada nativamente através de duas formas, auditoria simples (com AUDIT) ou auditoria fina (com Fine Grant Audit – FGA). De qualquer forma elas armazenam os registros em duas tabelas, aud$ e fga_log$.

Quando você habilita qualquer uma destas duas é importante gerenciar corretamente os registros de auditora, como por exemplo local de armazenamento, tempo de armazenamento e afins. É isso que vamos ver abaixo, como fazer isso automaticamente através do Oracle.

Tablespace
O primeiro passo é a tablespaces onde as duas tabelas (aud$ e fga_log$) armazenam os dados. Por padrão elas são armazenadas na tablespace system, mas você pode mudar isso. Quando a tablespace chega ao limite os registros param de serem inseridos e se a auditoria estiver na system, o banco todo congela (inclusive logins). Para evitar isso o método correto para mover a auditoria para outra tablespace é através do comando abaixo:

BEGIN
  
   --
   --Modificando para a  auditoria simples, a AUD$
   DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_LOCATION(
    audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_AUD_STD
    , audit_trail_location_value => 'TSAUDIT'
     );
  
   --
   --Modificando para a  auditoria de FGA, a FGA_LOG$
   DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_LOCATION(
    audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_FGA_STD
    , audit_trail_location_value => 'TSAUDIT'
     );    

END;

O parâmetro audit_trail_location_value define a tablespace destino e claro que antes de executar o comando acima você deve cria-la. Se você armazena muitos registros de auditoria recomenda-se criar a tablespace como bigfile, assim não terá o limite de 32GB. Se você já tiver dados nas tabelas de auditoria deverá criar a tablespace com tamanho inicial maior do que o tamanho atual das tabelas de auditoria.

No exemplo acima foram movidas as duas tabelas separadamente, mas você pode as duas ao mesmo tempo. Para isso basta mudar o parâmetro audit_trail_type conforme a tabela abaixo:

AUDIT_TRAIL_AUD_STD: Faz referência somente a aud$
AUDIT_TRAIL_FGA_STD: Faz referência somente a fga_log$
AUDIT_TRAIL_DB_STD: Ambas as tabelas, aud$ e fga_log$
Habilitando o Gerenciamento Automático
O gerenciamento automático da auditoria deve ser habilitado para permitir a movimentação de registros de auditoria entre tablespaces. Se você não moveu as tabelas aud$ e fga_log$ de tablespaces o Oracle automaticamente move os registros da SYSTEM para a SYSAUX. Caso já tenha movido ele não moverá nada. Observe o comando abaixo.

BEGIN
   DBMS_OUTPUT.ENABLE(10000);
   
--
--Verifica se o init foi habilitado para  as tabelas definidas

   IF NOT DBMS_AUDIT_MGMT.IS_CLEANUP_INITIALIZED(DBMS_AUDIT_MGMT.AUDIT_TRAIL_DB_STD)  THEN
    DBMS_OUTPUT.PUT_LINE('Limpeza de auditoria será inicializada');
   
--
--Inicializando a auditoria para a AUD$  e FGA

   DBMS_AUDIT_MGMT.INIT_CLEANUP(
    audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_DB_STD
     , default_cleanup_interval => 720
   );       

   ELSE

    DBMS_OUTPUT.PUT_LINE('Limpeza de  auditoria já inicializada');
    
   END IF;

END;

Através dele usamos a procedure DBMS_AUDIT_MGMT.IS_CLEANUP_INITIALIZED para verificar se o gerenciamento já foi habilitado. Caso não tenha sido, usamos a procedure DBMS_AUDIT_MGMT.INIT_CLEANUP para habilitar, e com um intervalo escolhido de 720 horas entre estas movimentações. Para Oracle 12C você pode especificar se deseja fazer isso para um PDB específico ou para todos.

Recomendo mover as tabelas de auditoria para uma tablespace específica, pois deixando no padrão não tem como especificar (através do INIT_CLEANUP) a data e hora que irá executar a movimentação e caso você tenha muitos dados pode impactar no ambiente. Mas caso você tenha poucos registros de auditoria o INIT_CLEANUP pode ser válido.

CREATE_PURGE_JOB
A forma mais fácil de habilitar o gerenciamento automático é criar o job de limpeza de auditoria através da procedure DBMS_AUDIT_MGMT.CREATE_PURGE_JOB. Observe:

BEGIN
   DBMS_AUDIT_MGMT.CREATE_PURGE_JOB(
    audit_trail_type =>  DBMS_AUDIT_MGMT.AUDIT_TRAIL_DB_STD
     , audit_trail_purge_interval => 720 --intervalo de limpeza, em  horas
     , audit_trail_purge_name  => 'JOB_Limpeza_Auditoria' --nome do job
     , use_last_arch_timestamp => TRUE 
   );                        
END;

Os parâmetros são:

audit_trail_type define qual o tipo de auditoria que você deseja limpar, segue a mesma tabela do início do texto.
audit_trail_purge_interval define o intervalo (em horas) que o job será chamado. Utilizará como base a data e hora que o job foi criado, no final será demonstrado como ajustar isso.
audit_trail_purge_name: define o nome do Job.
use_last_arch_timestamp: define quais s registro serão excluídos, TRUE indica que será com base em um valor definido (veremos como fazer isso abaixo) e FALSE o job removerá todos os registros.
Para o 12c podemos especificar, através do parâmetro container quais serão os afetados pelo job, todos ou somente o especificado. Quando você define todos, o job é criado no PDB root e este realiza a limpeza em todos os PDB’s.

Seguindo o exemplo acima, o job JOB_Limpeza_Auditoria irá ser executado a cada 720 horas (30 dias) e excluirá todos os registros de auditoria definidos pelo last_archive_time (explicarei no próximo tópico). O interessante do job automático é que o próprio kernel do Oracle se preocupa em localizar os registros a serem removidos e faz isso de forma controlada. Ele não remove todos através de um único delete, faz isso de forma escalonada a cada 10000 registros.

A data e hora que o job será executado depende do momento de execução do CREATE_PURGE_JOB. Como serão criados outros jobs auxiliares, mostrarei no final do artigo como aninhar todos e definir corretamente a execução destes.

Você pode verificar através da tabela DBA_AUDIT_MGMT_CLEANUP_JOBS  como ficou a configuração:

SQL>  COL JOB_NAME FORMAT A25
SQL>  COL JOB_FREQUENCY FORMAT A30
SQL>  COL AUDIT_TRAIL FORMAT A40
SQL>  SET LINESIZE 200 
SQL>  SELECT * FROM DBA_AUDIT_MGMT_CLEANUP_JOBS;

JOB_NAME                 JOB_STAT AUDIT_TRAIL                        JOB_FREQUENCY
------------------------ -------- ---------------------------------- ---------------------------
JOB_LIMPEZA_AUDITORIA    ENABLED  STANDARD AND FGA AUDIT TRAIL       FREQ=HOURLY;INTERVAL=720

SQL>
 

Marcando registros a serem excluídos
No procedimento acima utilizamos o parâmetro use_last_arch_timestamp como TRUE e isso define que a limpeza somente irá excluir os registros que definirmos e não toda a tabela. Para fazer isso usamos a procedure DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP.

Antes disso uma consideração, geralmente quando precisamos identificar algo na auditoria temos requisitos como: “O que João fez a 15 dias atrás?”, “Quem fez update na tabela salário este mês?”. Estes são exemplos, mas na grande maioria das vezes precisamos buscar o histórico e por isso é importante deixar alguns dias no banco para evitar restaurar backup para consulta auditoria.

Por isso que no procedimento que criou o job foi utilizado use_last_arch_timestamp como TRUE. Mas isso deixou o requisito de definir esse ponto até o momento no qual os dados não podem ser apagados. Pense nas tabelas de auditoria com o uma fila, precisamos marcar nessa fila até onde o job de limpeza pode deletar.

Para isso vamos utilizar a procedure DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP e também criar um job para fazer isso de forma automática (para que o job possa executar, criaremos uma procedure específica). A procedure criada:

CREATE  OR REPLACE PROCEDURE AUDIT_DefineMarcacaoAudit

  IS

  BEGIN

  DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP(
   audit_trail_type =>  DBMS_AUDIT_MGMT.AUDIT_TRAIL_AUD_STD
   , last_archive_time => SYSDATE - 45
    );                                                

  DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP(
   audit_trail_type =>  DBMS_AUDIT_MGMT.AUDIT_TRAIL_FGA_STD
   , last_archive_time => SYSDATE - 45
    );                                                

END;
 

A procedure acima utiliza DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP e marca que todos os registros de auditoria mais velhos que 45 dias (na data de execução da procedure) são marcados para exclusão. Também está separada a definição de datas para aud$ e fga_log$, assim fica mais fácil adaptar para requisitos diferentes de datas. Para deixar a marcação automatizada cria-se o job abaixo:

BEGIN
   
DBMS_SCHEDULER.CREATE_JOB(
    job_name           =>  'JOB_MarcaExclusaoAudit' --nome do job
    , job_type           =>  'STORED_PROCEDURE'
    , job_action         =>   'AUDIT_DefineMarcacaoAudit'
    , repeat_interval     =>  'FREQ=MONTHLY;INTERVAL=1'  -- uma vez ao mes
    , comments           =>  'Job que executa a procedure que marca ate  que ponto a auditoria pode ser removida'
   );

   --
   --Todo o job vem desabilitado por padrao no  scheduler do 11.2, habilitando

   DBMS_SCHEDULER.ENABLE(
    name => 'JOB_MarcaExclusaoAudit'
    );

END; 
 

O job acima executará 1 vez por mês e chamará a procedure que criamos antes. Assim, garantimos que 45 dias ficarão nas tabelas de auditoria. Se você observar, no momento que o job de limpeza for executar (ele executa a cada 30 dias também) você terá aproximadamente 75 dias dados armazenados, por isso é importante definir a tablespace de auditoria com um tamanho (ou tipo) condizente com o volume.

Aninhando JOBS
Os jobs criados acima estão marcados para executar com base no momento de criação e isso não é interessante. Além disso, não adianta executar o job de marcação de exclusão depois do job de limpeza. Para resolver isso podemos modificar os parâmetros dos jobs através do scheduler. Exemplo:

BEGIN

   --ajusta data inicial comum e aninhada
    DBMS_SCHEDULER.SET_ATTRIBUTE(
     name => 'JOB_MARCAEXCLUSAOAUDIT'
     , attribute => 'start_date'
     , value => TO_TIMESTAMP('15-JAN-13  12.00.00', 'DD-MON-RRRR HH24.MI.SS')
   );

   DBMS_SCHEDULER.SET_ATTRIBUTE(
    name => 'JOB_LIMPEZA_AUDITORIA'
     , attribute => 'start_date'
     , value => TO_TIMESTAMP('15-JAN-13  12.05.00', 'DD-MON-RRRR HH24.MI.SS')
   );
   
   --Segundo sabado do mes
   DBMS_SCHEDULER.SET_ATTRIBUTE(
    name => 'JOB_MARCAEXCLUSAOAUDIT'
     , attribute => 'repeat_interval'
     , value => 'FREQ=MONTHLY;  BYDAY=2SAT'
   );

   --Segundo sabado do mes
   DBMS_SCHEDULER.SET_ATTRIBUTE(
    name => 'JOB_LIMPEZA_AUDITORIA'
     , attribute => 'repeat_interval'
     , value => 'FREQ=MONTHLY;  BYDAY=2SAT'
   );   

END;
 

Com a definição acima temos:

JOB_MARCAEXCLUSAOAUDIT: O que importa aqui é a hora de execução, tem que ser antes do job de exclusão. A data inicial foi definida como 15 de Janeiro de 2013 (pode ser qualquer data) com horário para as 12:00. Também foi definido que ele será executado no segundo sábado de cada mês.
JOB_LIMPEZA_AUDITORIA: Também tem a data inicial como 15 de Janeiro de 2013, mas o horário é as 12:05. Isso garante que a limpeza sempre executará depois da marcação dos registros. E ele também executa no segundo sábado de cada mês.
Você pode modificar os valores acima com base nos seus requisitos, mas o importante é garantir que a marcação dos registros sempre ocorra antes da limpeza.

Tabelas importantes
Algumas tabelas de gerenciamento são importantes de serem acompanhadas. A primeira delas é a DBA_AUDIT_MGMT_CLEAN_EVENTS que registra todos os eventos automáticos de limpeza que ocorreram e quantos registros foram apagados para cada tabela (por isso aparecem separados):

SQL> COL CLEANUP_TIME FORMAT  A35
SQL> COL AUDIT_TRAIL  FORMAT A25
SQL> SET PAGESIZE 1000
SQL> SET LINESIZE 200
SQL> SELECT audit_trail,  cleanup_time, delete_count FROM DBA_AUDIT_MGMT_CLEAN_EVENTS ORDER BY  cleanup_time DESC;

AUDIT_TRAIL               CLEANUP_TIME                        DELETE_COUNT
------------------------- ----------------------------------- ------------
STANDARD AUDIT TRAIL      09-APR-16 10.33.53.867186 AM +00:00        56470
STANDARD AUDIT TRAIL      09-APR-16 10.33.53.865009 AM +00:00     25217082
STANDARD AUDIT TRAIL      20-MAR-16 10.00.40.545453 AM +00:00       742355
STANDARD AUDIT TRAIL      20-MAR-16 10.00.40.542995 AM +00:00     88551571
..
..
STANDARD AUDIT TRAIL      25-JUL-13 02.10.14.479176 PM +00:00       340175
STANDARD AUDIT TRAIL      25-JUL-13 02.10.14.465855 PM +00:00      9362182

68 rows selected.

SQL>
 

Outra tabela importante é DBA_AUDIT_MGMT_LAST_ARCH_TS que pode ser consulta para saber até onde foi a marcação de registros a serem limpos. No exemplo abaixo a marcação informa que o job de limpeza somente apagará registros até 26/02/2016 12:00:

SQL>  COL LAST_ARCHIVE_TS FORMAT A35
SQL>  SELECT * FROM DBA_AUDIT_MGMT_LAST_ARCH_TS;

AUDIT_TRAIL               RAC_INSTANCE LAST_ARCHIVE_TS
------------------------- ------------ ------------------------------------
STANDARD  AUDIT TRAIL                0 24-FEB-16  12.00.00.000000 AM +00:00
FGA  AUDIT TRAIL                     0 24-FEB-16 12.00.00.000000 AM  +00:00

SQL>
 

Outra tabela é a DBA_AUDIT_MGMT_CONFIG_PARAMS que mostra como os estão os parâmetros de gerenciamento da auditoria:

SQL>  COL PARAMETER_VALUE FORMAT A25
SQL>  COL PARAMETER_NAME FORMAT A25
SQL>  SELECT * FROM DBA_AUDIT_MGMT_CONFIG_PARAMS;

PARAMETER_NAME             PARAMETER_VALUE           AUDIT_TRAIL
-------------------------  ------------------------- -----------------------
DB  AUDIT TABLESPACE       TSAUDITTJ                 STANDARD AUDIT TRAIL
DB  AUDIT TABLESPACE       TSAUDITTJ                 FGA AUDIT TRAIL
AUDIT  FILE MAX SIZE       10000                     OS AUDIT TRAIL
AUDIT  FILE MAX SIZE       10000                     XML AUDIT TRAIL
AUDIT  FILE MAX AGE        5                         OS AUDIT TRAIL
AUDIT  FILE MAX AGE        5                         XML AUDIT TRAIL
DB  AUDIT CLEAN BATCH SIZE 10000                     STANDARD AUDIT TRAIL
DB  AUDIT CLEAN BATCH SIZE 10000                     FGA AUDIT TRAIL
OS  FILE CLEAN BATCH SIZE  1000                      OS AUDIT TRAIL
OS  FILE CLEAN BATCH SIZE  1000                      XML AUDIT TRAIL
DEFAULT  CLEAN UP INTERVAL 720                       STANDARD AUDIT TRAIL
DEFAULT  CLEAN UP INTERVAL 720                       FGA AUDIT TRAIL

12 rows selected.

SQL>
 

Como foram criados jobs manualmente é importante verificar a execução deles. Para isso utilizamos a tabela do próprio schedule. Observe os parâmetros (blocos e procedures) bem como as datas de execução aninhadas:

SQL>  COL OWNER FORMAT A5
SQL>  COL JOB_NAME FORMAT A25
SQL>  COL JOB_TYPE FORMAT A20
SQL>  COL REPEAT_INTERVAL FORMAT A25
SQL>  COL JOB_ACTION FORMAT A30
SQL>  COL START_DATE FORMAT A35
SQL>  COL NEXT_RUN_DATE FORMAT A35
SQL>  SET LINESIZE 300
SQL>  SELECT DSJ.OWNER, DSJ.JOB_NAME, DSJ.JOB_TYPE, DSJ.JOB_ACTION, DSJ.START_DATE, DSJ.REPEAT_INTERVAL, 
DSJ.NEXT_RUN_DATE, DSJ.RUN_COUNT, DSJ.FAILURE_COUNT
   2  FROM  DBA_SCHEDULER_JOBS DSJ
   3   WHERE JOB_NAME IN ('JOB_LIMPEZA_AUDITORIA', 'JOB_MARCAEXCLUSAOAUDIT');

OWNER JOB_NAME                  JOB_TYPE             JOB_ACTION                                                   
----- ------------------------- -------------------- -------------------------------------------------------------
SYS   JOB_LIMPEZA_AUDITORIA     PLSQL_BLOCK          BEGIN DBMS_AUDIT_MGMT.CLEAN_AUDIT_TRAIL(3,  TRUE);  END;     
SYS   JOB_MARCAEXCLUSAOAUDIT    STORED_PROCEDURE     AUDIT_DefineMarcacaoAudit                                    

START_DATE                           REPEAT_INTERVAL           NEXT_RUN_DATE                        RUN_COUNT 
-----------------------------------  ------------------------- -----------------------------------  --------- 
15-JAN-13 12.05.00.000000 AM -03:00  FREQ=MONTHLY; BYDAY=2SAT  14-MAY-16 12.05.00.700000 AM -03:00        34
15-JAN-13 12.00.00.000000 AM -03:00  FREQ=MONTHLY; BYDAY=2SAT  14-MAY-16 12.00.00.200000 AM -03:00        32

FAILURE_COUNT
-------------
            1
            0

SQL>
 

Outros cuidados
Se você desejar pode criar um job para mover as tabelas de auditoria de tempos em tempos (como por exemplo no 3º sábado do mês). Como as tabelas recebem deletes pelo job de limpeza o “início” dela fica desfragmentado e novos registros poderão ser adicionados no fim. Em resumo ela eventualmente pode nunca reduzir de tamanho.

Se você mover elas (através da DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_LOCATION) você garante que na nova tablespace somente o tamanho necessário é utilizado. Você também pode fazer um shrink se desejar. Se quiser fazer isso, crie uma procedure para mover e um job para automatizar o processo.

Todos os procedimentos acima foram executados com o usuário sys. Com mínimas adaptações você pode executar os procedimentos acima nos bancos Oracle 10.2 até o 12C.

Gerenciamento
Com tudo isso você tem um controle automatizado dos seus registros de auditoria. Garantindo que você consiga consultar dados históricos de auditoria sem precisar voltar backup. Além disso garante que as tablespaces system e sysaux não ficarão cheias de registros.

Referências
DBMS_AUDIT_MGMT para 11.2 (https://docs.oracle.com/cd/E18283_01/appdev.112/e16760/d_audit_mgmt.htm)
DBMS_AUDIT_MGMT para 12C (https://docs.oracle.com/database/121/ARPLS/d_audit_mgmt.htm)

 

Fernando Simon DBA do Tribunal de Justiça de Santa Catarina. Trabalha como DBA a diversos anos, desde o Oracle 9i até o Oracle 12c. Tem experiência prática com Oracle Exadata (do V2 ao X5) e soluções que dependem de High Availability como Zero Data Loss, Data Guard, Oracle RAC e replicações diversas. Também atua como palestrante em eventos Oracle no Brasil. Blog: http://www.fernandosimon.com/blog.

Este artigo foi revisto pela equipe de produtos Oracle e está em conformidade com as normas e práticas para o uso de produtos Oracle.


















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Oracle Database 12c Security: "Auditoria no 12c: Unified Auditing" ( Part I )
Por Joel Perez , Aman Sharma , Karan Dodwal (OCM) & Carlos H. Y. Furushima 
Postado em Abril 2015

Revisado por Marcelo Pirovar - Solution Architect

Introdução
Uma função do administradores de banco de dados (DBA) é zelar pela segurança do banco de dados, é comum verificar que muitos recursos de segurança não são implementados ou operam em configurações default (padrão de fábrica). Devido a heterogeneidade das soluções em cenários de infra-estrutura de TI e possíveis riscos/desvios na integração entre essas soluções heterogêneas, faz com que o DBA fique engessado para implementação de certos métodos de autenticação não-local (kerberos por exemplo). Contudo ainda é de sua responsabilidade, saber quem está entrando/saindo e utilizando seu banco de dados, uma forma eficiente e fácil de fazer isso é por meio da auditoria.

Tipos de auditoria (Auditingoptions) antes do 12c
Em versões anteriores ao 12c, o DBA pode implementar cinco tipos de configuração de auditoria, são elas:

MandatoryAuditing (Auditoria obrigatória) - Essa auditoria está sempre habilitada e monitora o shutdown e startup do banco de dados e operações de logon como SYSDBA, SYSASM ou SYSOPER.
Standard Auditing (Padrão auditoria) - Essa auditoria é opcionalmente habilitada pelo DBA, para auditar instrução SQL, privilégios, schema objects e atividade de rede (network) ou multicamadas (multitier). Este tipo de auditoria é definida e controlada sob o nível de banco de dados.
Value-basedAuditing (Auditoria baseada em valor) - Auditoria baseada em valor (Value-basedAuditing) foi introduzida com intuito de capturar operações que modificam valores, ou seja, operações DML que ocorre na tabela, esse tipo de auditoria utiliza-se de triggers de banco de dados, onde essa é disparada em função de um evento de alteração (operação DML).
Fine-GrainedAuditing (Auditoria refinada): Auditoria refinada (Fine grainedauditing) é uma auditoria que visa capturar ações baseadas no conteúdo acessado ou modificado, onde são criadas diretivas (policies) para disparar eventos de auditoria (trigger auditevents) quando alguém tenta executar ações sobre a condição especificada na definição da política.
SysAuditing (auditoria do sys) - Este tipo de auditoria permite que o DBA, seja monitorado, ao se logar com SYS, suas ações serão gravadas em um arquivo do sistema operacional mesmo que audit_trail é definido como none. O parâmetro de instance AUDIT_SYS_OPERATIONS controla a habilitação ou desativação da auditoria do sys.
Além destas soluções, para proteger as informações de seus sistemas, ha também o Oracle AuditVault uma plataforma corporativa de auditoria e monitoramento de segurança. Combinada todas essas opções, cria-se um robusto sistema de monitoramento, possibilitando o DBA ter um arsenal completo no combate a usuário mal-intencionado, atividades suspeitas e/ou desvios de conduta.

O tem de errado com as opções de auditoria disponível no 11g?
Na verdade, não há nada de errado com as opções disponíveis, contudo, a gestão da auditoria para o DBA neste cenário é extremamente trabalhosa. Por exemplo, para habilitar o Standard Auditing (Padrão auditoria), os parâmetros AUDIT_TRAIL e AUDIT_FILE_DEST, devem ser setados. Se você estiver planejando usar o Fine-GrainedAuditing (Auditoria refinada) ou somente o Standard Auditing, os registros de auditoria (auditrecords), são armazenados em SYS.FGA_LOG$ ou SYS.AUD$, isso demanda uma atenção especial no armazenamento, uma vez que essas tabelas, tentem a crescer em função do uso do banco de dados e com o passar do tempo, os registros de auditoria (auditrecords) ficarão obsoletos, obrigando o DBA, criar tarefas de expurgo. Caso estiver usando algo mais robusto como Oracle AuditVault, é papel do DBA, gerenciar as tabelas com os dados do Vault, como DVSYS.AUDIT_TRAIL$, para usuários como o SYS, registros de auditoria (auditrecords) são criados usando o usuário ROOT, o que pode dificultar a gestão, no que se refere a processos de TI da companhia, uma vez que nem sempre o DBA tem o acesso de super usuário (ROOT). Resumindo, isso significa, que há muita coisa envolvida (necessidade de hardware, mão de obra, planejamento no processo de TI, etc.), do que apenas habilitar a auditoria para o banco de dados.

Introdução a UnifiedAuditing
Foi introduzida no Oracle 12c um novo mecanismo de auditoria, onde este novo regime, permite agrupar várias diretivas de auditoria em uma única politica, por este motivo, é empregado o termo "Unified" (unificação) como prefixo de "UnifiedAuditing". É possível criar políticas baseado em ações e condições. A implementação deste novo tipo de política é controlada por um novo usuário (schema AUDSYS), onde suas tabelas para trilha de auditoria (auditingtrailtables - metadados de auditoria) são somente leitura (read-only), até mesmo para o usuário SYS, com isso todos os tipos de trilhas de auditoria seriam gerenciados por um único usuário e em uma tabela de trilha de auditoria, ou seja, torna esta informação disponível em um formato uniforme, a concessão de acesso para os dados de trilha de auditoria, permite duas perspectiva, viewer (ver os dados) ou admin (administrar os dados).

Arquitetura de diretiva da UnifiedAuditing

O usuário owner do "unifiedauditing" (Auditoria unificada) é o AUDSYS. Na SGA, existem background queues (queuesin-memory - duas por client), que armazenam as entradas de auditoria (Auditrecords) de forma volátil, para que posteriormente sejam armazenadas de forma permanente em disco, o flush (despacho das entradas de auditoria) é feito pelo novo processo background GEN0 (processo de execução de tarefas gerais - General TaskExecution process) ou de forma manual utilizando a DBMS_AUDIT_MGMT, o armazenamento é feito em uma tabela somente leitura localizado no schema AUDSYS no tablespace SYSAUX.

A trilha de auditoria unificada (unifiedaudittrail), reside em uma tabela somente leitura (Read-Only) no esquema AUDSYS no tablespace SYSAUX, torna esta informação disponível em um formato uniforme na view de dicionário de dados UNIFIED_AUDIT_TRAIL, ou seja, todas as trilhas de auditoria existentes no 11g, foram unificadas em uma única trilha agora no 12c (view UNIFIED_AUDIT_TRAIL).

OBS.: Para executar o flush manual das entradas de auditoria (Auditrecords) localizado no background queues para o schema AUDSYS.

Exec SYS.DBMS_AUDIT_MGMT.Flush_Unified_Audit_Trail;

Ha duas background queues (filas) por server process (em conexões do tipo dedicada), assim quando um background queue (uma fila) está cheia, seu conteúdo é despachado para disco pelo background GEN0 e o server process (por exemplo RMAN), pode usar a outra background queue (uma fila) para armazenar de forma volátil suas informações de auditoria. A quantidade de memória alocada dentro da SGA que será dedicada para todas as background queues (filas) é 1MB, esse valor pode ser alterado pelo DBA via parâmetro de instance UNIFIED_AUDIT_SGA_QUEUE_SIZE (valor default = 1MB e valor máximo = 30MB). A decisão de alterar o valor de memória alocada deve ser feita com base no montante esperado (workload - quantidade) de informações de auditoria a ser gerados. Para a maioria dos sistemas, o padrão de 1MB deve ser suficiente.

Ha dois diferentes modo de operação, referente a escrita das entradas de auditoria para área de armazenamento permanente (disco), como citado anteriormente, as entradas de auditoria quando geradas, são primeiramente armazenadas em área volátil (SGA) e posteriormente escrito para área permanente (disco) via processo GEN0, essa escrita pode ser imediata ou sob demanda (quando a background queue chegar no seu limite máximo de capacidade). O modo de escrita (gravação) imediata, faz com que a frequência de I/O, seja mais intensa e como consequência, é necessário que o subsistema I/O comporte essa a pressão que está sendo exercida, caso contrário, o sistema como um todo, iria ser impactando, degradando o desempenho significativamente. É possível alterar o modo de operação utilizando o pacote DBMS_AUDIT_MGMT.

Modo de operação imediata (Immediate-Write mode)

EXECUTE DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_PROPERTY  ( DBM_MS_AUDIT_MGMT.AUDIT_TRAIL_UNIFIED,
DBMS_AUDIT_MGMT.AUDIT_TRAIL_WRITE_MODE,
DBMS_AUDIT_MGMT.AUDIT_TRAIL_IMMEDIATE_MODE );


Modo de operação sob demanda (Queued-Write mode) # Default

EXECUTE  DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_PROPERTY (  DBM_MS_AUDIT_MGMT.AUDIT_TRAIL_UNIFIED,
DBMS_AUDIT_MGMT.AUDIT_TRAIL_WRITE_MODE, 
DBMS_AUDIT_MGMT.AUDIT_TRAIL_QUEUED_MODE );


O default é sempre o modo de operação sob demanda.
OBS.: É importante ressaltar que se houve um crash instance (queda da instance), pode haver um perda das entradas de auditoria, caso o processo background GEN0 não completar a escrita para disco.


Implementando UnifiedAuditing
Em banco de dados que passaram por um processo de upgrade release para 12c ou um banco de dados recém criado, a unifiedauditing (auditoria unificada) não está habilitada por default na versão 12c (12.1.0.2), em caso de uma herança de políticas de auditoria, oriunda de versões pre-12c (por exemplo, 11gR2 ou inferior, quando unifiedauditing não existia) é possível manter o mecanismo antigo, migrar para o novo ou usar ambos em um modo misto (MixedAuditmode).
Para banco de dados que passaram por um processo de upgrade release para 12c, quaisquer diretivas ou políticas de auditoria (audit policies) previamente configurados em seus respectivos destinos permaneceram habilitadas. Além deles, é possível criar novas diretiva usando o comando CREATE AUDIT POLICY e habilita-la usando o comando AUDIT. É possíveltambém utilizar diretivas pré-definida (template de auditoria) como ORA_SECURECONFIG, ORA_ACCOUNT_MGMT e ORA_DATABASE_PARAMETER, essas diretivas/políticas são criadas juntamente com o banco de dados, usando o script secconf.sql, que está localizado em $ORACLE_HOME/rdbms/admin.


Este artigo continua na sua parte II: Oracle Database 12c Security: "Auditoria no 12c: Unified Auditing" (Part II)


Joel Pérez é um DBA Especialista (Oracle ACE Director, OCM Cloud Admin. & OCM11g ). Com mais de 14 anos de experiência do mundo Oracle Technology, especializado em arquitetura e implementação de soluções como: Cloud, Alta disponibilidade, Disaster/Recovery, Upgrades, replicação e todos as áreas relacionadas com bancos de dados Oracle. Consultor internacional com deveres, conferências e atividades em mais de 50 países e inúmeros clientes em todo o mundo. Palestrante regular nos eventos Oracle em todo o mundo como: OTN LAD, OTN MENA, OTN APAC e muito mais. Joel sempre foi conhecido por ser pioneiro em tecnologia Oracle desde os primeiros dias de sua carreira sendo o primeiro latino-americano premiado como "OTN Expert" no ano de 2003 pela Oracle Corporation, um dos primeiros "ACE Oracle" no Oracle ACE Program no ano de 2004, um dos primeiros OCP Database Cloud Administrator em todo o mundo no ano de 2013 e como um das maiores realizações profissionais em sua carreira, recentemente ele foi homenageado como o primeiro "OCM Database Cloud Administrator" do mundo.

Aman Sharma é um especialista em banco de dados Oracle, um Oracle Certified Professional (9i, 10g, 11g), um Oracle Certified Expert para Linux e SQL e Sun Certified System Admin com mais de 6 anos de experiência. Aman trabalha como instrutor de formação de profissionais ao redor da Ásia-Pacífico em tecnologias da Oracle relacionadas. Antes disso, ele trabalhou como DBA para uma empresa de desenvolvimento de software de grande porte. Em seu tempo livre, quando Aman não está ensinando ou viajando, ele gosta de passar o tempo em vários fóruns da Oracle através da web.

Karan Dodwal (OCM) é um Oracle arquiteto com especialização em Oracle High Availability. Ele é um DBA Oracle Certified Master (OCM) com vários anos de experiência em banco de dados Oracle e no desenvolvimento Oracle. Ele trabalha como consultor Oracle e já realizou diversos serviços e treinamentos sobre os produtos da Oracle na Ásia Pacífico, Ásia do Sul e na Grande China. Ele é um speaker do All India Oracle Users Group (North India Chapter) e apresenta sessões no Oracle Technology. Ele tem várias configuração feitas do Oracle High Availability em todas as plataformas para missões críticas do Oracle Database. Ele é um expert em todas as soluções de High Availability da Oracle como RAC, Exadata, Data Guard e outros. Ele freqüentemente publica artigos em diversos sites e no seu bloghttp://karandba.blogspot.in e participa ativamente de eventos do grupo de usuários Oracle AIOUG AllIndia Oracle UsersGroup (North IndiaChapter) e ajuda diversos usuário no OTN Fórum da Oracle.

Carlos H. Y. Furushima é um especialista em banco de dados relacional, trabalhando como consultor de TI, atuando principalmente como o Oracle Database Administrator (DBA Oracle). Tem uma vasta experiência e conhecimento em "Performance, diagnosticand tuning", "High Availability", "Backup & Recovery" e "Exadata". Ele também está entusiasmado com sistema operacional Linux/Unix, onde contribui com o desenvolvimento do código do kernel Linux em parceria com a comunidade "GNU Linux", com criação e revisão de novas funcionalidades, melhorias e correções de bugs. Recentemente, Furushima divide seu tempo com consultoria especializada em banco de dados Oracle e estudos sobre "Oracle Internals", com o objetivo de descobrir e entender os benefícios do bancos de dados Oracle em plataforma Linux/Unix.

Este artigo foi revisto pela equipe de produtos Oracle e está em conformidade com as normas e práticas para o uso de produtos Oracle.

    E-mail this page E-mail this page    Printer View Printer View








FONTE: https://www.oracle.com/technetwork/pt/articles/idm/auditoria-security-database-12c-2524430-ptb.html
















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


12c Unified Auditing and AUDIT_TRAIL=DB in mixed mode
By Oracle TeamFebruary 23, 2017Database Administration & Monitoring2 Comments
    
By Franck Pachot
.
Oracle enables some auditing by default, and if you don’t do anything, the tables where it is stored will grow in SYSAUX. Don’t wait to get an alert when it is too late. Everything that fills something automatically must be managed to archive or purge automatically. If not, one day you will have a problem.

Imagine that you have 5 features doing something similar but in a different way because they were implemented one at a time. You want to stop this and have only 1 unified feature. That’s great. But you are also required to maintain compatibility with previous version, which means that you actually implemented a 5+1=6th feature 🙁

Unified Auditing
This exactly what happens with Unified Auditing. Because of this compatibility requirement, it is declined in two modes:

The ‘mixed mode’ that keeps all compatibility as the 5+1 case in my example
The ‘pure mode’ that do not take care of the past and is actually the one that unifies all. The real ‘Unified’ one.
You are in ‘mixed mode’ by default and you see it as if there is nothing new enabled:

SQL> select parameter,value from v$option where parameter='Unified Auditing';
 
PARAMETER VALUE
--------- -----
Unified Auditing FALSE

But there may be something enabled if the old auditing is enabled, because it is actually a mixed mode.

AUDIT_TRAIL=DB
Let me explain. I use the old auditing:

SQL> show parameter audit
NAME TYPE VALUE
---------------------------- ------- --------------------------------
audit_trail string DB

This means that I have the default audits (such as logon, logoff, ALTER/CREATE/DROP/GRANT ANY, and so on.
In addition to that, I enabled the audit of create table:

SQL> audit create table;
Audit succeeded.

I do some of these stuff and I can see info in the old audit trail:
SQL> select action_name,sql_text from dba_audit_trail;
 
ACTION_NAME SQL_TEXT
----------- --------
CREATE TABLE
LOGON
SELECT
LOGON
LOGOFF

If you are in that case, you probably manage this trail. Our recommandation is either to disable audit, or to manage it.

But once upgraded to 12c, did you think about managing the new unified audit trail?

SQL> select audit_type,unified_audit_policies,action_name,return_code,count(*) from unified_audit_trail group by audit_type,unified_audit_policies,action_name,return_code order by 1,2,3;
---- ------ ------------------------------------------------------------------ ---- ------------------- ----- -- --------------------------------------------------------- ----- -- ------
AUDIT_TYPE UNIFIED_AUDIT_POLICIES ACTION_NAME RETURN_CODE COUNT(*)
Standard ORA_LOGON_FAILURES LOGON 0 2
Standard ORA_LOGON_FAILURES LOGON 1017 1
Standard ORA_SECURECONFIG CREATE ROLE 0 1
Standard ORA_SECURECONFIG DROP ROLE 0 1
Standard EXECUTE 0 1

Even with Unified Auditing set to off, some operations are audited when AUDIT_TRAIL=DB. If you don’t want them you have to disable them:

noaudit policy ORA_SECURECONFIG;
noaudit policy ORA_LOGON_FAILURES;

As you see, in mixed mode the new unified auditing is enabled, and AUDIT_TRAIL is not ignored. This is the mode to use until you have migrated all your policies and audit trail queries to the new one. However you can see that in mixed mode, there is no double auditing but only new default policies. The old policies are only logged to the old audit trail.

But if you don’t use auditing, then you don’t want the mixed mode.

uniaud_on
This is done with an instance shutdown, relinking onLinux or renaming a ddl on Windows.


SQL> shutdown immediate;
ORACLE instance shut down.
SQL> host ( cd $ORACLE_HOME/rdbms/lib ; make -f ins_rdbms.mk uniaud_&2 ioracle ORACLE_HOME=$ORACLE_HOME )
/usr/bin/ar d /u01/app/oracle/product/12.2.0/dbhome_1/rdbms/lib/libknlopt.a kzanang.o
/usr/bin/ar cr /u01/app/oracle/product/12.2.0/dbhome_1/rdbms/lib/libknlopt.a /u01/app/oracle/product/12.2.0/dbhome_1/rdbms/lib/kzaiang.o
chmod 755 /u01/app/oracle/product/12.2.0/dbhome_1/bin
 
- Linking Oracle
...

And then you are in ‘pure mode’:


SQL> select parameter,value from v$option where parameter='Unified Auditing';
 
PARAMETER VALUE
--------- -----
Unified Auditing TRUE

In that mode, AUDIT_TRAIL is ignored and you will never see new rows in the old AUD$:

SQL> select action_name,sql_text from dba_audit_trail;
 
no rows selected

However, as in the mixed mode you will have to manage the new audit trail. My best recommandation is to keep it and add a purge job. One day you may want to have a look at unsuccessful logins of the past few days. But you still have the choice to disable the default polices, and then the only things you will see are the operations done on the trail:

AUDIT_TYPE UNIFIED_AUDIT_POLICIES ACTION_NAME SQL_TEXT
---------- ---------------------- ----------- --------
Standard EXECUTE BEGIN dbms_audit_mgmt.flush_unified_audit_trail; END;^@
Standard EXECUTE BEGIN dbms_audit_mgmt.clean_audit_trail(audit_trail_type => dbms_audit_mgmt.audi
Standard EXECUTE BEGIN dbms_audit_mgmt.flush_unified_audit_trail; END;^@

The reason is that if a hacker getting super administrator rights has tried to whipe his traces, then at least this suspect operation remains.

Test it
To validate this blog post, I’ve tested all scenarios on 12.2.0.1 with the combination of:

audit_trail=db or audit_trail=none
uniaud_on or uniaud_off
audit or noaudit policy for ORA_SECURECONFIG and ORA_LOGON_FAILURES
For each combination, I’ve purged both audit trails (AUD$ and AUD$UNIFIED) and run a few statements that are logged by default or by explicit audit.

So what?
Basically, the recommandation is still the same as before: either disable the audit or schedule a purge. There is no purge by default because auditing is different than logging. When your security policy is to audit some operations, they must not be purged before being archived, or processed.

When you upgrade to 12c:

If you want to manage only the old audit, then you should disable ORA_LOGON_FAILURES and ORA_SECURECONFIG.
If you want to manage both, then add a job to purge the unified audit trail (audit_trail_type=>dbms_audit_mgmt.audit_trail_unified).
If you don’t use the old auditing, then enable the ‘pure mode’. But then, AUDIT_TRAIL=NONE is ignored, so:
If you don’t use the new unified auditing, then disable ORA_LOGON_FAILURES and ORA_SECURECONFIG.
Or use the new unified auditing and set a job to purge it regularly.
And control the growth of SYSAUX:

SQL> select occupant_name,schema_name,occupant_desc,space_usage_kbytes from v$sysaux_occupants where occupant_name like 'AUD%';
 
OCCUPANT_NAME SCHEMA_NAME OCCUPANT_DESC SPACE_USAGE_KBYTES
------------- ----------- ------------- ------------------
AUDSYS AUDSYS AUDSYS schema objects 1280
AUDIT_TABLES SYS DB audit tables 0

SYS ‘DB audit tables’ is the old one, filled in ‘mixed mode’ only. AUDSYS ‘AUDSYS schema objects’ is the new unified one, filled in both modes.

But I have something to add. The default policies do not audit something that you are supposed to do so frequently, it should not fills hundreds of MB before several decades.
If you get this during the last hour:
SQL> select audit_type,unified_audit_policies,action_name,return_code,count(*)
2 from unified_audit_trail where event_timestamp>sysdate-1
3 group by audit_type,unified_audit_policies,action_name,return_code
4 order by count(*);
AUDIT_TYPE UNIFIED_AUDIT_POLICIES ACTION_NAME RETURN_CODE COUNT(*)
---------- ---------------------- ----------- ----------- --------
Standard AUDIT 0 2
Standard EXECUTE 0 4
Standard ORA_SECURECONFIG CREATE ROLE 0 9268
Standard ORA_LOGON_FAILURES LOGON 1017 348 

then the problem is not auditing but an attack, either from a hacker of because of your application design connecting for each execution or running DDL all the time.




FONTE: https://blog.dbi-services.com/12c-unified-auditing-and-audit_traildb-in-mixed-mode/















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------








  /******************************************************************************************************************************
  *                                                   		REFERENCIAS      	                                  				          *
  *https://www.youtube.com/watch?v=pfRqZUyLPQY&t=56s							                		   		   				                          *
  *https://www.youtube.com/watch?v=5OF3JJUx6dE																	   				                                      *
  *https://www.youtube.com/watch?v=rSLv1mge_uw 																	   				                                      *
  *https://www.oracle.com/technetwork/pt/articles/database-performance/gerenciamento-automatico-auditoria-3002076-ptb.html		  *
  *https://www.oracle.com/technetwork/pt/articles/idm/auditoria-security-database-12c-2524430-ptb.html                          *
  *https://blog.dbi-services.com/12c-unified-auditing-and-audit_traildb-in-mixed-mode/                                          *
  *https://www.youtube.com/watch?v=pHjvR_4gSwo                                                                                  *
  *******************************************************************************************************************************/